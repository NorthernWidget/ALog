<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Logger (for ALog): Logger Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ALog_logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Logger (for ALog)
   &#160;<span id="projectnumber">v0.2 for ALog 2.0</span>
   </div>
   <div id="projectbrief">Open-source Arduino-based field data logger</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classLogger-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Logger Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abc41bfb031d896170c7675fa96a6b30c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#abc41bfb031d896170c7675fa96a6b30c">Logger</a> ()</td></tr>
<tr class="memdesc:abc41bfb031d896170c7675fa96a6b30c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLogger.html">Logger</a> library for the Arduino-based ALog data logger.  <a href="#abc41bfb031d896170c7675fa96a6b30c">More...</a><br /></td></tr>
<tr class="separator:abc41bfb031d896170c7675fa96a6b30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9495e2c8e63850f3c7cfcc31e9d73ffe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a9495e2c8e63850f3c7cfcc31e9d73ffe">initialize</a> (char *_logger_name, char *_sitecode, int _dayInterval, int _hourInterval, int _minInterval, int _secInterval, bool _ext_int=false, bool _LOG_ON_BUCKET_TIP=false)</td></tr>
<tr class="separator:a9495e2c8e63850f3c7cfcc31e9d73ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e0bd543758c65a17b77553a0e9f0c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#ab5e0bd543758c65a17b77553a0e9f0c9">setupLogger</a> ()</td></tr>
<tr class="separator:ab5e0bd543758c65a17b77553a0e9f0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90ff8f29410f6b70cc6334391400a4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#ad90ff8f29410f6b70cc6334391400a4e">sleep</a> ()</td></tr>
<tr class="separator:ad90ff8f29410f6b70cc6334391400a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6c78dd1715b33ae4bbd6f66f116f77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a4a6c78dd1715b33ae4bbd6f66f116f77">startLogging</a> ()</td></tr>
<tr class="separator:a4a6c78dd1715b33ae4bbd6f66f116f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82814d61687debcf3b8dd6f46c9d549"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#aa82814d61687debcf3b8dd6f46c9d549">endLogging</a> ()</td></tr>
<tr class="separator:aa82814d61687debcf3b8dd6f46c9d549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af936c7f58e23316abb5614cbd31c7ced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#af936c7f58e23316abb5614cbd31c7ced">startAnalog</a> ()</td></tr>
<tr class="separator:af936c7f58e23316abb5614cbd31c7ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca7be8a63592263c67f63766680d16f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#adca7be8a63592263c67f63766680d16f">endAnalog</a> ()</td></tr>
<tr class="separator:adca7be8a63592263c67f63766680d16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc758b6fdaac8099c492929aa7f1691d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#acc758b6fdaac8099c492929aa7f1691d">get_use_sleep_mode</a> ()</td></tr>
<tr class="separator:acc758b6fdaac8099c492929aa7f1691d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343fcabefb37e06429865a2e6a6e708a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a343fcabefb37e06429865a2e6a6e708a">readPin</a> (int pin)</td></tr>
<tr class="separator:a343fcabefb37e06429865a2e6a6e708a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e67526c65fa865f276a515a200af4aa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a4e67526c65fa865f276a515a200af4aa">readPinOversample</a> (int pin, int bits)</td></tr>
<tr class="separator:a4e67526c65fa865f276a515a200af4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73193a90982ddcb31ad0b401ec0e71fa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a73193a90982ddcb31ad0b401ec0e71fa">analogReadOversample</a> (int pin, int adc_bits=10, int nsamples=1, debug=false)</td></tr>
<tr class="separator:a73193a90982ddcb31ad0b401ec0e71fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343dbf1edb8745ea9672f579d3e8297e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a343dbf1edb8745ea9672f579d3e8297e">thermistorB</a> (float R0, float B, float Rref, float T0degC, int thermPin, uint8_t ADC_resolution_nbits=14, bool Rref_on_GND_side=true;bool oversample_debug=false)</td></tr>
<tr class="separator:a343dbf1edb8745ea9672f579d3e8297e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362a1462166d63ddc613eaa1e86f9854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a362a1462166d63ddc613eaa1e86f9854">ultrasonicMB_analog_1cm</a> (int nping, int EX, int sonicPin, bool writeAll)</td></tr>
<tr class="separator:a362a1462166d63ddc613eaa1e86f9854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ce56cb9c3dfc7abfd6308b2ee7dc10"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a87ce56cb9c3dfc7abfd6308b2ee7dc10">maxbotixHRXL_WR_Serial</a> (int Ex, int nping, bool writeAll, int maxRange, bool RS232=false)</td></tr>
<tr class="separator:a87ce56cb9c3dfc7abfd6308b2ee7dc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05378a90963ceebf7dad0904a74f42f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#aa05378a90963ceebf7dad0904a74f42f">maxbotixHRXL_WR_analog</a> (int nping=10, int sonicPin=A0, int EX=99, bool writeAll=true, uint8_t ADC_resolution_nbits=13)</td></tr>
<tr class="separator:aa05378a90963ceebf7dad0904a74f42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ae372dee7f672a6d6f33ab441e4da1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a40ae372dee7f672a6d6f33ab441e4da1">Decagon5TE</a> (int excitPin, int dataPin)</td></tr>
<tr class="separator:a40ae372dee7f672a6d6f33ab441e4da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84da6a9ec3d4d56fdc32d950b71f1a26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a84da6a9ec3d4d56fdc32d950b71f1a26">DecagonGS1</a> (int pin, float Vref, uint8_t ADC_resolution_nbits=14)</td></tr>
<tr class="separator:a84da6a9ec3d4d56fdc32d950b71f1a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ae31b2bdb77c86fb6851907258171b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#ab1ae31b2bdb77c86fb6851907258171b">vdivR</a> (int pin, float Rref, uint8_t ADC_resolution_nbits=10, bool Rref_on_GND_side=true)</td></tr>
<tr class="separator:ab1ae31b2bdb77c86fb6851907258171b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dc18b7b16c91de5f7a3af7edb381a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a12dc18b7b16c91de5f7a3af7edb381a9">linearPotentiometer</a> (int linpotPin, float Rref, float slope, float intercept=0, uint8_t ADC_resolution_nbits=14)</td></tr>
<tr class="separator:a12dc18b7b16c91de5f7a3af7edb381a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdcbb56e3e4910ac895ee150fe1b9ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a9fdcbb56e3e4910ac895ee150fe1b9ed">AtlasScientific</a> (char *command, int softSerRX=6, int softSerTX=7, uint32_t baudRate=38400, bool printReturn=true, bool saveReturn=true)</td></tr>
<tr class="separator:a9fdcbb56e3e4910ac895ee150fe1b9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccff7a14a6bddc8bb28e22b3b36d3cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a4ccff7a14a6bddc8bb28e22b3b36d3cc">HTM2500LF_humidity_temperature</a> (int humidPin, int thermPin, float Rref_therm, uint8_t ADC_resolution_nbits=14)</td></tr>
<tr class="separator:a4ccff7a14a6bddc8bb28e22b3b36d3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0eda5a0be93a4d8505c7493d0f5e333"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#af0eda5a0be93a4d8505c7493d0f5e333">HM1500LF_humidity_with_external_temperature</a> (int humidPin, float Vref, float R0, float B, float Rref, float T0degC, int thermPin, uint8_t ADC_resolution_nbits=14)</td></tr>
<tr class="separator:af0eda5a0be93a4d8505c7493d0f5e333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ffb193feceb75b2e19a3617d00455c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a91ffb193feceb75b2e19a3617d00455c">Inclinometer_SCA100T_D02_analog_Tcorr</a> (int xPin, int yPin, float Vref, float Vsupply, float R0, float B, float Rref, float T0degC, int thermPin, uint8_t ADC_resolution_nbits=14)</td></tr>
<tr class="separator:a91ffb193feceb75b2e19a3617d00455c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6a43a1b86f88c2a5e33d14c992e510"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a6c6a43a1b86f88c2a5e33d14c992e510">Anemometer_reed_switch</a> (int interrupt_pin_number, unsigned long reading_duration_milliseconds, float meters_per_second_per_rotation)</td></tr>
<tr class="separator:a6c6a43a1b86f88c2a5e33d14c992e510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c3cba5ff5722fb66bf540bfbe8b25d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a31c3cba5ff5722fb66bf540bfbe8b25d">Wind_Vane_Inspeed</a> (int vanePin)</td></tr>
<tr class="separator:a31c3cba5ff5722fb66bf540bfbe8b25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4190ce7ccfd7b148a6151102a3bf93d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#ae4190ce7ccfd7b148a6151102a3bf93d">Pyranometer</a> (int analogPin, float raw_mV_per_W_per_m2, float gain, float V_ref, uint8_t ADC_resolution_nbits=14)</td></tr>
<tr class="separator:ae4190ce7ccfd7b148a6151102a3bf93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923b296832bd4222da649ebc66427ac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a923b296832bd4222da649ebc66427ac1">HackHD</a> (int control_pin, bool want_camera_on)</td></tr>
<tr class="separator:a923b296832bd4222da649ebc66427ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ea885397f448ac03675b1e9a93ecfd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogger.html#a71ea885397f448ac03675b1e9a93ecfd">Honeywell_HSC_analog</a> (float Vsupply, float Pmin, float Pmax, int TransferFunction_number, int units, int pin, uint8_t ADC_resolution_nbits=14)</td></tr>
<tr class="separator:a71ea885397f448ac03675b1e9a93ecfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abc41bfb031d896170c7675fa96a6b30c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Logger::Logger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classLogger.html">Logger</a> library for the Arduino-based ALog data logger. </p>
<p>ALog data logger library: methods to:</p><ul>
<li>Initialize the data logger</li>
<li>Sleep and wake</li>
<li>Interact with the real-time clock (RTC)</li>
<li>Write data to the SD card</li>
<li>Manage power</li>
<li>Interact with a range of sensors</li>
</ul>
<p>All help documentation here assumes you have created an instance of the "Logger" </p><div class="fragment"><div class="line">logger <a class="code" href="classLogger.html#abc41bfb031d896170c7675fa96a6b30c">Logger</a>();</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a73193a90982ddcb31ad0b401ec0e71fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Logger::analogReadOversample </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>adc_bits</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nsamples</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">debug&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Higher analog resolution through oversampling</p>
<p>This function incorporates oversampling to extend the ADC precision past ten bits by taking more readings and statistically combing them.</p>
<p>Returns a floating point number between 0 and 1023 in order to be intechangable with the Arduino core AnalogRead() function</p>
<p>It is often used within other sensor functinons to increase measurement precision.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>is the analog pin number</td></tr>
    <tr><td class="paramname">adc_bits</td><td>is the reading precision in bits (2^adc_bits). The ATMega328 (Arduino Uno and ALog BottleLogger core chip) has a base ADC precision of 10 bits (returns values of 0-1023) A reasonable maximum precision gain is (base_value_bits)+6, so 16 bits is a reasonable maximum precision for the ALog BottleLogger.</td></tr>
    <tr><td class="paramname">nsamples</td><td>is the number of times you want to poll the particular sensor and write the output to file.</td></tr>
    <tr><td class="paramname">debug</td><td>is a flag that, if true, will write all of the values read during the oversampling to "Oversample.txt".</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// 12-bit measurement of Pin 2</span></div><div class="line"><span class="comment">// Leaves nsamples at its default value of 1 (single reading of sensor)</span></div><div class="line">logger.analogReadOversample(2, 12);</div></div><!-- fragment --><p>Readings that require more bits of precision will take longer.</p>
<p>For analog measurements that do not require more than 10 bits of precision, use logger.readpin(int pin) or the standard Arduino "AnalogRead" function.</p>
<p>Based on eRCaGuy_NewAnalogRead::takeSamples(uint8_t analogPin)</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Take a single sample at 14-bit resolution and store it as &quot;myReading&quot;</span></div><div class="line">myReading = logger.analogReadOversample(A3, 14, 1);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6c6a43a1b86f88c2a5e33d14c992e510"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::Anemometer_reed_switch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interrupt_pin_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>reading_duration_milliseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>meters_per_second_per_rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Anemometer that flips a reed switch each time it spins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interrupt_pin_number</td><td>is the digital pin number corresponding to the appropriate interrupt; it uses the Arduino digitalPinToInterrupt(n_pin) function to properly attach the interrupt</td></tr>
    <tr><td class="paramname">reading_duration_milliseconds</td><td>How long will you count revolutions? Shorter durations save power, longer durations increase accuracy; very long durations will produce long-term averages. Typical values are a few seconds.</td></tr>
    <tr><td class="paramname">meters_per_second_per_rotation</td><td>Conversion factor between revolutions and wind speed. For the Inspeed Vortex wind sensor that we have used (<a href="http://www.inspeed.com/anemometers/Vortex_Wind_Sensor.asp">http://www.inspeed.com/anemometers/Vortex_Wind_Sensor.asp</a>), this is: <b>2.5 mph/Hz = 1.1176 (m/s)/Hz</b></td></tr>
  </table>
  </dd>
</dl>
<p>This function depends on the global variable <b>rotation_count</b>.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// 4-second reading with Inspeed Vortex wind sensor on digital pin 3</span></div><div class="line"><span class="comment">// (interrupt 1), returned in meters per second</span></div><div class="line">logger.Anemometer_reed_switch(3, 4000, 1.1176);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9fdcbb56e3e4910ac895ee150fe1b9ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::AtlasScientific </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>softSerRX</em> = <code>6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>softSerTX</em> = <code>7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudRate</em> = <code>38400</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>printReturn</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveReturn</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atlas Scientific sensors: water properties and chemistry.</p>
<p>Generalized serial interface for Atlas Scientific sensors. It uses SoftwareSerial AND THEREFORE IS LIKELY UNSTABLE AFTER A FEW DAYS IN THE FIELD. The watchdog timer SHOULD BE ABLE TO CATCH THIS, but this has not yet been tested.</p>
<p>Code in comments is on the way to replacing this with hardware serial. It is also possible to replace this with I2C code, which will be more versitile: can connect many sensors to same I2C port, so long as they remain isolated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>is the instruction code sent to the Atlas Scientific product. See the data sheet for your specific sensor.</td></tr>
    <tr><td class="paramname">softSerRx</td><td>is the software serial receive port</td></tr>
    <tr><td class="paramname">softSerTx</td><td>is the software serial transmit port</td></tr>
    <tr><td class="paramname">baudRate</td><td>is set by the Atlas Scientific sensor's baud rate.</td></tr>
    <tr><td class="paramname">printReturn</td><td>is true if you determines whether you care about (i.e. want to print) the Serial response, and false if you would just like to clear the buffer.</td></tr>
    <tr><td class="paramname">saveReturn</td><td>is true if you want to save the response to the SD card.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// read a pH probe using pins 7 and 8 as Rx and Tx, and save its results:</span></div><div class="line">logger.AtlasScientific(<span class="stringliteral">&quot;R&quot;</span>, 7, 8);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a40ae372dee7f672a6d6f33ab441e4da1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::Decagon5TE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>excitPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dataPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a Decagon Devices 5TE soil moisture probe.</p>
<p>NEEDS TESTING with current ALog version.</p>
<p>Returns Dielectric permittivity [-unitless-], electrical conductivity [dS/m], and temperature [degrees C]. Soil moisture is calculated through postprocessing.</p>
<p>Uses <b>SoftwareSerial</b>, and therefore has the potential to go unstable; however, we have a time limit, so this won't crash the logger: it will just keep the logger from recording good data.</p>
<p>Modified from Steve Hicks' code for an LCD reader by Andy Wickert</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">excitPin</td><td>activates the probe and powers it</td></tr>
    <tr><td class="paramname">dataPin</td><td>receives incoming serial data at 1200 bps</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line">logger.Decagon5TE(7, 8);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a84da6a9ec3d4d56fdc32d950b71f1a26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::DecagonGS1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Vref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ADC_resolution_nbits</em> = <code>14</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ruggedized Decagon Devices soil moisture sensor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Analog pin number</td></tr>
    <tr><td class="paramname">Vref</td><td>is the reference voltage of the ADC; on the ALog, this is a precision 3.3V regulator (unless a special unit without this regulator is ordered; the regulator uses significant power)</td></tr>
    <tr><td class="paramname">ADC_resolution_nbits</td><td>(10-16 for the ALog BottleLogger) is the number of bits of ADC resolution used (oversampling for &gt;10 bits)</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Using a non-precision Rref that is slightly off</span></div><div class="line">logger.DecagonGS1(A1, 3.27, 14);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adca7be8a63592263c67f63766680d16f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::endAnalog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turn off power to analog sensors</p>

</div>
</div>
<a class="anchor" id="aa82814d61687debcf3b8dd6f46c9d549"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::endLogging </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Endslogging and returns to sleep</p>
<p>Ends line, turns of SD card, and resets alarm: ready to sleep.</p>
<p>Also runs tipping bucket rain gauge code (function that records time stamp) if one is attached and activated.</p>
<p><b>IMPORTANT:</b> If the logger is not writing data to the card, and the card is properly inserted, the manually-set delay here may be the problem. We think we have made it long enough, but because it is hard-coded, there could be an unforeseen circumstance in which it is not!</p>

</div>
</div>
<a class="anchor" id="acc758b6fdaac8099c492929aa7f1691d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Logger::get_use_sleep_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does the logger enter a low-power sleep mode? T/F.</p>
<ul>
<li>True if the logger is going to sleep between pases through the data-reading loop.</li>
<li>False if the logger is looping over its logging step (inside void loop() in the *.ino code) continuously without sleeping</li>
</ul>

</div>
</div>
<a class="anchor" id="a923b296832bd4222da649ebc66427ac1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::HackHD </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>control_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>want_camera_on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HackHD camera control function</p>
<p>Control the HackHD camera: this function turns the HackHD on or off and records the time stamp from when the HackHD turns on/off in a file called "camera.txt".</p>
<p>Because this function turns the camera on or off, you have to ensure that you write a mechanism to keep it on for some time in your code. This could be checking the time each time you wake and deciding what to do, for example. In short: this function is a lower-level utility that requires the end-user to write the rest of the camera control sequence themselves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">control_pin</td><td>is the pin connected to the HackHD on/off switch; Dropping control_pin to GND for 200 ms turns camera on or off.</td></tr>
    <tr><td class="paramname">want_camera_on</td><td>is true if you want to turn the camera on, false if you want to turn the camera off.</td></tr>
    <tr><td class="paramname">CAMERA_IS_ON</td><td>is a global varaible attached to this function that saves the state of the camera; it will be compared to "want_camera_on", such that this function will do nothing if the camera is already on (or off) and you want it on (or off).</td></tr>
  </table>
  </dd>
</dl>
<p>Power requirements:</p>
<ul>
<li>0.2 mA quiescent current draw;</li>
<li>600 mA while recording</li>
</ul>
<p>Example (not tested):</p>
<div class="fragment"><div class="line"><span class="comment">// Before &quot;setup&quot;:</span></div><div class="line">uint32_t t_camera_timeout_start_unixtime;</div><div class="line"><span class="keywordtype">int</span> timeout_secs = 300;</div><div class="line">book camera_on = <span class="keyword">false</span>;</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// Inside &quot;loop&quot;:</span></div><div class="line"><span class="comment">// Turn the camera on after some triggering event, and keep it on for as </span></div><div class="line"><span class="comment">// long as this condition is met, and for at least 5 minutes afterwards.</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// &gt;&gt; some code to measure a variable&#39;s &quot;distance&quot;</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="keywordflow">if</span> (distance &lt; 1500){</div><div class="line">  logger.HackHD(8, <span class="keyword">true</span>);</div><div class="line">  camera_on = <span class="keyword">true</span>; <span class="comment">// Maybe I can get a global variable from this library</span></div><div class="line">                    <span class="comment">// or have HackHD function return the camera state?</span></div><div class="line">  now = RTC.now();</div><div class="line">  <span class="comment">// Reset the timeout clock</span></div><div class="line">  t_camera_timeout_start_unixtime = now.unixtime(); </div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>(camera_on){</div><div class="line">  now = RTC.now();</div><div class="line">  <span class="comment">// If timed out, turn it off.</span></div><div class="line">  <span class="keywordflow">if</span> ((t_camera_timeout_start_unixtime - now.unixtime()) &gt; timeout_secs){</div><div class="line">    logger.HackHD(8, <span class="keyword">false</span>);</div><div class="line">    camera_on = <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>This example could be used to capture flow during a flash flood. See:</p><ul>
<li>Website: <a href="http://instaar.colorado.edu/~wickert/atvis/">http://instaar.colorado.edu/~wickert/atvis/</a></li>
<li>AGU poster: <a href="https://www.researchgate.net/publication/241478936_The_Automatically_Triggered_Video_or_Imaging_Station_ATVIS_An_Inexpensive_Way_to_Catch_Geomorphic_Events_on_Camera">https://www.researchgate.net/publication/241478936_The_Automatically_Triggered_Video_or_Imaging_Station_ATVIS_An_Inexpensive_Way_to_Catch_Geomorphic_Events_on_Camera</a></li>
</ul>

</div>
</div>
<a class="anchor" id="af0eda5a0be93a4d8505c7493d0f5e333"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::HM1500LF_humidity_with_external_temperature </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>humidPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Vref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>R0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Rref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>T0degC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thermPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ADC_resolution_nbits</em> = <code>14</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HM1500LF Relative humidity sensor with external temperature correction</p>
<p>This function measures the relative humidity of using a HTM1500 relative humidity sensor and an external thermistor. The relative humidity and temperature is measured using a 14 bit oversampling method. Results are displayed on the serial monitor and saved onto the SD card to four decimal places.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">humidPin</td><td>is the analog pin connected to the humidity output voltage of the module.</td></tr>
    <tr><td class="paramname">R0_therm</td><td>is a thermistor calibration.</td></tr>
    <tr><td class="paramname">B_therm</td><td>is the B- or β- parameter of the thermistor.</td></tr>
    <tr><td class="paramname">Rref_therm</td><td>is the resistance of the corresponding reference resistor for that analog pin.</td></tr>
    <tr><td class="paramname">T0degC_therm</td><td>is a thermistor calibration.</td></tr>
    <tr><td class="paramname">thermPin_therm</td><td>is the analog pin connected to the tempurature output voltage of the module.</td></tr>
    <tr><td class="paramname">ADC_resolution_nbits</td><td>(10-16 for the ALog BottleLogger) is the number of bits of ADC resolution used (oversampling for &gt;10)</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line">logger.HTM2500LF_humidity_temperature(1,?,10000,3950,10000,25,2);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a71ea885397f448ac03675b1e9a93ecfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Logger::Honeywell_HSC_analog </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Vsupply</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Pmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Pmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>TransferFunction_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ADC_resolution_nbits</em> = <code>14</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cost-effective pressure sensor from Honeywell</p>
<p>Datasheet: <a href="http://sensing.honeywell.com/index.php?ci_id=151133">http://sensing.honeywell.com/index.php?ci_id=151133</a></p>
<p>See also the <b>Honeywell_HSC_analog</b> example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Analog pin number</td></tr>
    <tr><td class="paramname">Vsupply</td><td>Supply voltage to sensor</td></tr>
    <tr><td class="paramname">Vref</td><td>is the reference voltage of the ADC; on the ALog, this is a precision 3.3V regulator (unless a special unit without this regulator is ordered; the regulator uses significant power)</td></tr>
    <tr><td class="paramname">Pmin</td><td>Minimum pressure in range of sensor</td></tr>
    <tr><td class="paramname">Pmax</td><td>Maximum pressure in range of sensor</td></tr>
    <tr><td class="paramname">Pmax</td><td>Maximum pressure in range of sensor</td></tr>
    <tr><td class="paramname">TransferFunction_number</td><td>1, 2, 3, or 4: which transfer function is used to convert voltage to pressure<ul>
<li>TransferFunction: 1 = 10% to 90% of Vsupply ("A" in second to last digit of part number)</li>
<li>TransferFunction: 2 = 5% to 95% of Vsupply ("A" in second to last digit of part number)</li>
<li>TransferFunction: 3 = 5% to 85% of Vsupply ("A" in second to last digit of part number)</li>
<li>TransferFunction: 4 = 4% to 94% of Vsupply ("A" in second to last digit of part number)</li>
</ul>
</td></tr>
    <tr><td class="paramname">Units</td><td>Output units<ul>
<li>Units: 0 = mbar</li>
<li>Units: 1 = bar</li>
<li>Units: 2 = Pa</li>
<li>Units: 3 = KPa</li>
<li>Units: 4 = MPa</li>
<li>Units: 5 = inH2O</li>
<li>Units: 6 = PSI</li>
</ul>
</td></tr>
    <tr><td class="paramname">ADC_resolution_nbits</td><td>(10-16 for the ALog BottleLogger) is the number of bits of ADC resolution used (oversampling for &gt;10 bits)</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line">logger.Honeywell_HSC_analog(A1, 5, 3.3, 0, 30, 1, 6);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4ccff7a14a6bddc8bb28e22b3b36d3cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::HTM2500LF_humidity_temperature </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>humidPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thermPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Rref_therm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ADC_resolution_nbits</em> = <code>14</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HTM2500LF Relative humidity and temperature sensor</p>
<p>This function measures the relative humidity of using a HTM2500 tempurature and relative humidity module. The relative humidity and temperature is measured using a 14 bit oversampling method. Results are displayed on the serial monitor and saved onto the SD card to four decimal places.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">humidPin</td><td>is the analog pin connected to the humidity output voltage of the module.</td></tr>
    <tr><td class="paramname">thermPin</td><td>is the analog pin connected to the tempurature output voltage of the module.</td></tr>
    <tr><td class="paramname">Rref_therm</td><td>is the value of the reference resistor that you use with the built-in thermistor (reference resistor supplied separately, placed in appropriate slot in header)</td></tr>
    <tr><td class="paramname">ADC_resolution_nbits</td><td>(10-16 for the ALog BottleLogger) is the number of bits of ADC resolution used (oversampling for &gt;10)</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line">logger.HTM2500LF_humidity_temperature(1, 2, ?);</div></div><!-- fragment --><p>This function is designed for ratiometric operation &ndash; that is, the humidity sensor must be powered by the same voltage regulator that is connected to the the analog reference pin &ndash; for the ALog v2.0, this is a high-precision 3V3 regulator.</p>

</div>
</div>
<a class="anchor" id="a91ffb193feceb75b2e19a3617d00455c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::Inclinometer_SCA100T_D02_analog_Tcorr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Vref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Vsupply</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>R0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Rref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>T0degC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thermPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ADC_resolution_nbits</em> = <code>14</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inclinometer, including temperature correction from an external sensor.</p>
<ul>
<li>+/- 90 degree inclinometer, measures +/- 1.0g</li>
<li>Needs 4.75&ndash;5.25V input (Vsupply)</li>
<li>In typical usage, turned on and off by a switching 5V charge pump or boost converter</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xPin</td><td>Analog pin number corresponding to x-oriented tilts</td></tr>
    <tr><td class="paramname">yPin</td><td>Analog pin number corresponding to y-oriented tilts</td></tr>
    <tr><td class="paramname">Vref</td><td>is the reference voltage of the analog-digital comparator; it is 3.3V on the ALog.</td></tr>
    <tr><td class="paramname">Vsupply</td><td>is the input voltage that drives the sensor, and is typically ~5V.</td></tr>
    <tr><td class="paramname">humidPin</td><td>is the analog pin connected to the humidity output voltage of the module.</td></tr>
    <tr><td class="paramname">R0_therm</td><td>is a thermistor calibration.</td></tr>
    <tr><td class="paramname">B_therm</td><td>is the B- or β- parameter of the thermistor.</td></tr>
    <tr><td class="paramname">Rref_therm</td><td>is the resistance of the corresponding reference resistor for that analog pin.</td></tr>
    <tr><td class="paramname">T0degC_therm</td><td>is a thermistor calibration.</td></tr>
    <tr><td class="paramname">thermPin_therm</td><td>is the analog pin connected to the tempurature output voltage of the module.</td></tr>
    <tr><td class="paramname">ADC_resolution_nbits</td><td>(10-16 for the ALog BottleLogger) is the number of bits of ADC resolution used (oversampling for &gt;10). It is applied to both the inclinomter and its temperature correction</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line">logger.Inclinometer_SCA100T_D02_analog_Tcorr(6, 2, 3.285, 5.191, \</div><div class="line">       10080.4120953, 3298.34232031, 10000, 25, 0);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9495e2c8e63850f3c7cfcc31e9d73ffe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::initialize </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>_logger_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>_sitecode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_dayInterval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_hourInterval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_minInterval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_secInterval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_ext_int</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_LOG_ON_BUCKET_TIP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pass all variables needed to initialize logging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_logger_name</td><td>Name associated with this data logger; often helps to relate it to the project or site</td></tr>
    <tr><td class="paramname">_filename</td><td>Name of main data file saved to SD card; often helps to relate it to the project or site; used to be limited to 8.3, but now is not.</td></tr>
    <tr><td class="paramname">_dayInterval</td><td>How many days to wait before logging again; can range from 0-6.</td></tr>
    <tr><td class="paramname">_hourInterval</td><td>How many hours to wait before logging again; can range from 0-24.</td></tr>
    <tr><td class="paramname">_minInterval</td><td>How many minutes to wait before logging again; can range from 0-59.</td></tr>
    <tr><td class="paramname">_secInterval</td><td>How many seconds to wait before logging again; can range from 0-59.</td></tr>
  </table>
  </dd>
</dl>
<p>If all time-setting functions are 0, then the logger will not sleep, and instead will log continuously. This sets the flag "_use_sleep_mode" to be false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_ext_int</td><td>External interrupt, set to be a tipping-bucket rain gauge, that triggers event-based logging of a timestamp</td></tr>
    <tr><td class="paramname">_LOG_ALL_SENSORS_ON_BUCKET_TIP</td><td>Flag that tells the logger to read every sensor when the bucket tips (if _ext_int is true) and write their outputs to "datafile" (i.e. the main data file whose name you specify with <b>_filename</b>; this is in addition to writing the timestamp of the rain gauge bucket tip.</td></tr>
  </table>
  </dd>
</dl>
<p>Data logger model does not need to be set: it is automatically determined from the MCU type and is used to modify pinout-dependent functions.</p>
<p>Example: </p><div class="fragment"><div class="line">\\ Log every five minutes</div><div class="line">logger.initialize(<span class="stringliteral">&#39;TestLogger01&#39;</span>, <span class="stringliteral">&#39;lab_bench_test.alog&#39;</span>, 0, 0, 5, 0);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a12dc18b7b16c91de5f7a3af7edb381a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::linearPotentiometer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>linpotPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Rref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>slope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>intercept</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ADC_resolution_nbits</em> = <code>14</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Linear potentiometer (radio tuner) to measure distance</p>
<p>Distance based on resistance in a sliding potentiometer whose resistance may be described as a linear function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linpotPin</td><td>Analog pin number</td></tr>
    <tr><td class="paramname">Rref</td><td>Resistance value of reference resistor [ohms]</td></tr>
    <tr><td class="paramname">slope</td><td>Slope of the line (distance = (slope)R + R0)</td></tr>
    <tr><td class="paramname">intercept</td><td>(R0) of the line (distance = (slope)R + R0)</td></tr>
    <tr><td class="paramname">ADC_resolution_nbits</td><td>(10-16 for the ALog BottleLogger) is the number of bits of ADC resolution used (oversampling for &gt;10 bits)</td></tr>
    <tr><td class="paramname">Rref_on_GND-Side</td><td>indicates the configuration of the voltage divider. True if using Alog provided Reference resistor terminals. If false, the reference resitor must be instead connected via the screw terminals. This is set true for external sensors that are built to require a VCC-side reference resistor.</td></tr>
  </table>
  </dd>
</dl>
<p>The output units will be whatever you have used to create your linear calibration equation</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Using a 0-10k ohm radio tuner with units in mm and a perfect intercept;</span></div><div class="line"><span class="comment">// maintaining default 14-bit readings with standard-side (ALog header)</span></div><div class="line"><span class="comment">// reference resistor set-up</span></div><div class="line">logger.linearPotentiometer(A0, 5000, 0.0008);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa05378a90963ceebf7dad0904a74f42f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::maxbotixHRXL_WR_analog </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nping</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sonicPin</em> = <code>A0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>EX</em> = <code>99</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeAll</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ADC_resolution_nbits</em> = <code>13</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Newer 1-mm precision MaxBotix rangefinders: analog readings</p>
<p>This function measures the distance between the ultrasonic sensor and an \ acoustically-reflective surface, typically water or snow. Measures distance in milimeters. Results are displayed on the serial monitor and saved onto the SD card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nping</td><td>is the number of range readings to take (number of pings). The mean range will be calculated and output to the serial monitor and SD card followed by the standard deviation.</td></tr>
    <tr><td class="paramname">sonicPin</td><td>is the analog input channel hooked up to the maxbotix sensor.</td></tr>
    <tr><td class="paramname">EX</td><td>is a digital output pin used for an excitation pulse. * If maxbotix sensor is continuously powered, a reading will be taken when this pin is flashed high. Set to '99' if excitation pulse is not needed.</td></tr>
    <tr><td class="paramname">writeAll</td><td>will write each reading of the sensor (each ping) to the serial monitor and SD card.</td></tr>
    <tr><td class="paramname">ADC_resolution_nbits</td><td>(10-16 for the ALog BottleLogger) is the number of bits of ADC resolution used (oversampling for &gt;10 bits)</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line">logger.ultrasonicMB_analog_1cm(10, 99, 2, 0);</div></div><!-- fragment --><p> Note that sensor should be mounted away from supporting structure. These are the standard recommendations:</p><ul>
<li>For a mast that is 5 meters high (or higher) the sensor should be mounted at least 100cm away from the mast.</li>
<li>For a mast that is 2.5 meters high (or lower) the sensor should be at least 75cm away from the mast.</li>
</ul>
<p><b>However, in our tests, the sensors with filtering algorithms function perfectly well even when positioned close to the mast, and a short mast increases the rigidity of the installation. This was tested in the lab by placing the MaxBotix sensor flush with table legs and testing distance readings to the floor.</b></p>

</div>
</div>
<a class="anchor" id="a87ce56cb9c3dfc7abfd6308b2ee7dc10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Logger::maxbotixHRXL_WR_Serial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeAll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>RS232</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses the UART interface to record data from a MaxBotix sensor.</p>
<p>NOTE: THIS HAS CUASED LOGGERS TO FREEZE IN THE PAST; WHILE IT IS QUITE LIKELY THAT THE ISSUE IS NOW SOLVED, MORE TESTING IS REQUIRED. (ADW, 26 NOVEMBER 2016) (maybe solved w/ HW Serial?)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ex</td><td>Excitation pin that turns the sensor on; if this is not needed (i.e. you are turning main power off and on instead), then just set this to a value that is not a pin, and ensure that you turn the power to the sensor off and on outside of this function</td></tr>
    <tr><td class="paramname">npings</td><td>Number of pings over which you average; each ping itself includes ten short readings that the sensor internally processes</td></tr>
    <tr><td class="paramname">writeAll</td><td>will write each reading of the sensor (each ping) to the serial monitor and SD card.</td></tr>
    <tr><td class="paramname">maxRange</td><td>The range (in mm) at which the logger maxes out; this will be remembered to check for errors and to become a nodata values</td></tr>
    <tr><td class="paramname">RS232</td><td>this is set true if you use inverse (i.e. RS232-style) logic; it works at standard logger voltages (i.e. it is not true RS232). If false, TTL logic will be used.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Digital pin 7 controlling sensor excitation, averaging over 10 pings,</span></div><div class="line"><span class="comment">// not recording the results of each ping, and with a maximum range of </span></div><div class="line"><span class="comment">// 5000 mm using standard TTL logic</span></div><div class="line">logger.maxbotixHRXL_WR_Serial(7, 10, <span class="keyword">false</span>, 5000, <span class="keyword">false</span>);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae4190ce7ccfd7b148a6151102a3bf93d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::Pyranometer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>analogPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>raw_mV_per_W_per_m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>V_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ADC_resolution_nbits</em> = <code>14</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pyranometer wtih instrumentation amplifier</p>
<p>Pyranomiter is from Kipp and Zonen</p>
<p>nominal raw_output_per_W_per_m2_in_mV = 10./1000.; // 10 mV at 1000 W/m**2</p>
<p>Actual raw output is based on calibration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">analogPin</td><td>is the pin that receives the amplified voltage input</td></tr>
    <tr><td class="paramname">raw_mV_per_W_per_m2</td><td>is the conversion factor of the pyranometer: number of millivolts per (watt/meter^2). This does not include amplification!</td></tr>
    <tr><td class="paramname">gain</td><td>is the amplification factor</td></tr>
    <tr><td class="paramname">V_ref</td><td>is the reference voltage of the ADC; on the ALog, this is a precision 3.3V regulator (unless a special unit without this regulator is ordered; the regulator uses significant power)</td></tr>
    <tr><td class="paramname">ADC_resolution_nbits</td><td>(10-16 for the ALog BottleLogger) is the number of bits of ADC resolution used (oversampling for &gt;10 bits)</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Using precision voltage reference and 16-bit resolution (highest</span></div><div class="line"><span class="comment">// defensible oversampling resolution)</span></div><div class="line">logger.Pyranometer(A0, 0.0136, 120, 3.300, 16);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a343fcabefb37e06429865a2e6a6e708a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Logger::readPin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the analog value of a pin.</p>
<p>This function returns the analog to digital converter value (0 - 1023). Results are displayed on the serial monitor and saved onto the SD card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>is the analog pin number to be read.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line">logger.readPin(2);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4e67526c65fa865f276a515a200af4aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Logger::readPinOversample </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the analog value of a pin, with extra resolution from oversampling</p>
<p>This function incorporates oversampling to extend the ADC precision past ten bits by taking more readings and statistically combing them. Results are displayed on the serial monitor and saved onto the SD card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>is the analog pin number to be read.</td></tr>
    <tr><td class="paramname">adc_bits</td><td>is the reading precision in bits (2^adc_bits). The ATMega328 (Arduino Uno and ALog BottleLogger core chip) has a base ADC precision of 10 bits (returns values of 0-1023) A reasonable maximum precision gain is (base_value_bits)+6, so 16 bits is a reasonable maximum precision for the ALog BottleLogger.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line">logger.readPinOversample(2, 12);</div></div><!-- fragment --><p>Output values will range from 0-1023, but be floating-point.</p>
<p>Readings that require more bits of precision will take longer.</p>

</div>
</div>
<a class="anchor" id="ab5e0bd543758c65a17b77553a0e9f0c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::setupLogger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Readies the ALog to begin measurements</p>
<p>Sets all pins, alarms, clock, SD card, etc: everything needed for the ALog to run properly.</p>

</div>
</div>
<a class="anchor" id="ad90ff8f29410f6b70cc6334391400a4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Puts the ALog data logger into a low-power sleep mode</p>
<p>Sets the "IS_LOGGING" flag to false, disables the watchdog timer, and puts the logger to sleep.</p>

</div>
</div>
<a class="anchor" id="af936c7f58e23316abb5614cbd31c7ced"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::startAnalog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turn on power to analog sensors</p>

</div>
</div>
<a class="anchor" id="a4a6c78dd1715b33ae4bbd6f66f116f77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::startLogging </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wakes the logger and starts logging</p>
<p>Wakes the logger: sets the watchdog timer (a failsafe in case the logger hangs), checks and clears alarm flags, looks for rain gauge bucket tips (if they occur during the middle of a logging event (ignore) or if they include a command to read all sensors with a tip), and starts to log to "datafile", if it can.</p>
<p><b>If the logger cannot reach the SD card, it sends out an LED warning message of 20 rapid flashes.</b></p>

</div>
</div>
<a class="anchor" id="a343dbf1edb8745ea9672f579d3e8297e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Logger::thermistorB </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>R0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Rref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>T0degC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thermPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ADC_resolution_nbits</em> = <code>14</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Rref_on_GND_side</em> = <code>true;&#160;bool&#160;oversample_debug=false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the analog value of a pin, with extra resolution from oversampling</p>
<p>This function measures temperature using a thermistor characterised with the B (or β) parameter equation, which is a simplification of the Steinhart-Hart equation</p>
<p>The function compares the thermistor risistance with the reference resistor using a voltage divider.</p>
<p>It returns a float of the temperature in degrees celsius. Results are displayed on the serial monitor and saved onto the SD card to four decimal places.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R0</td><td>is the resistance of the thermistor at the known temperature </td></tr>
    <tr><td class="paramname">T0degC</td><td></td></tr>
    <tr><td class="paramname">B</td><td>is the β parameter of the thermistor</td></tr>
    <tr><td class="paramname">Rref</td><td>is the resistance of the corresponding reference resistor for \ the analog pin set by <b>ThermPin</b> (below).</td></tr>
    <tr><td class="paramname">T0degC</td><td>is the temperature at which <b>R0</b> was calibrated.</td></tr>
    <tr><td class="paramname">thermPin</td><td>is the analog pin number to be read.</td></tr>
    <tr><td class="paramname">ADC_resolution_nbits</td><td>(10-16 for the ALog BottleLogger) is the number of bits of ADC resolution used (oversampling for &gt;10 bits)</td></tr>
    <tr><td class="paramname">Rref_on_GND-Side</td><td>indicates the configuration of the voltage divider. True if using Alog provided Reference resistor terminals. If false, the reference resitor must be instead connected via the screw terminals. This is set true for external sensors that are built to require a VCC-side reference resistor.</td></tr>
    <tr><td class="paramname">oversample_debug</td><td>is true if you want a separate file, "Oversample.txt", to record every individual reading used in the oversampling.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Contherm from Digikey, 14-bit precision</span></div><div class="line">logger.thermistorB(10000, 3950, 30000, 25, 2, 14);</div><div class="line"><span class="comment">// EPCOS, DigiKey # 495-2153-ND, 14-bit precision</span></div><div class="line">logger.thermistorB(10000, 3988, 13320, 25, 1, 14);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a362a1462166d63ddc613eaa1e86f9854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::ultrasonicMB_analog_1cm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>EX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sonicPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeAll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Old 1-cm resolution Maxbotix ultrasonic rangefinders: analog measurements</p>
<p>This function measures the distance between the ultrasonic sensor and an acustically reflective surface, typically water or snow. Measures distance in centimeters. Results are displayed on the serial monitor and saved onto the SD card.</p>
<p>This is for the older MaxBotix sensors, whose maximum precision is in centimeters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nping</td><td>is the number of range readings to take (number of pings). The mean range will be calculated and output to the serial monitor and SD card followed by the standard deviation.</td></tr>
    <tr><td class="paramname">EX</td><td>is a digital output pin used for an excitation pulse. If maxbotix sensor is continuously powered a reading will be taken when this pin is flashed high. Set to '99' if excitation pulse is not needed.</td></tr>
    <tr><td class="paramname">sonicPin</td><td>is the analog input channel hooked up to the maxbotix sensor.</td></tr>
    <tr><td class="paramname">writeAll</td><td>will write each reading of the sensor (each ping) to the serial monitor and SD card.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line">logger.ultrasonicMB_analog_1cm(10, 99, 2, 0);</div></div><!-- fragment --><p> Note that sensor should be mounted away from supporting structure. For a mast that is 5 meters high (or higher) the sensor should be mounted at least 100cm away from the mast. For a mast that is 2.5 meters high (or lower) the sensor should be at least 75cm away from the mast.</p>

</div>
</div>
<a class="anchor" id="ab1ae31b2bdb77c86fb6851907258171b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::vdivR </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Rref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ADC_resolution_nbits</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Rref_on_GND_side</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resistance from a simple voltage divider</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Analog pin number</td></tr>
    <tr><td class="paramname">Rref</td><td>Resistance value of reference resistor [ohms]</td></tr>
    <tr><td class="paramname">ADC_resolution_nbits</td><td>(10-16 for the ALog BottleLogger) is the number of bits of ADC resolution used (oversampling for &gt;10 bits)</td></tr>
    <tr><td class="paramname">Rref_on_GND-Side</td><td>indicates the configuration of the voltage divider. True if using Alog provided Reference resistor terminals. If false, the reference resitor must be instead connected via the screw terminals. This is set true for external sensors that are built to require a VCC-side reference resistor.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Use standard reference resistor headers: let last parameter be false </span></div><div class="line"><span class="comment">// (default)</span></div><div class="line">logger.vdivR(A2, 10000, 12);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a31c3cba5ff5722fb66bf540bfbe8b25d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Logger::Wind_Vane_Inspeed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vanePin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wind vane: resistance changes with angle to wind.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vanePin</td><td>is the analog pin that reads the wind vane resistance</td></tr>
  </table>
  </dd>
</dl>
<p>This function is specialized for the Inspeed eVane2. Here, a resistance of 0 equates to wind from the north, and resistence increases in a clockwise direction.</p>
<p>Connect one wire to power supply, one wire to analog pin, one wire to GND</p>
<p>From documentation:</p><ul>
<li>5 - 95% of power supply input voltage = 0 to 360 degrees of rotation.</li>
<li>Uses Hall Effect Sensor</li>
<li>Don't forget to use set screw to zero wind sensor before starting!</li>
</ul>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// After setting up and zeroing the eVane to North, you wire it to </span></div><div class="line"><span class="comment">// analog pin 7 on the ALog</span></div><div class="line">logger.Wind_Vane_Inspeed(A7);</div></div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Logger_8h_source.html">Logger.h</a></li>
<li><a class="el" href="Logger_8cpp.html">Logger.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
